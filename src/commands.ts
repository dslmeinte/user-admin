import {isObject, isString} from "lodash";
import {v4} from "uuid";

import {Event, EventType, IAddIdentityToGroupEvent, ICreateGroupEvent, ICreateUserEvent} from "./events";
import {Identities} from "./identities";


export type Command = ICreateUserCommand | ICreateGroupCommand | IAddIdentityToGroupCommand;

export type CommandType = EventType;


export /* abstract */ interface ICommand {
    commandType: CommandType;
}

export interface IAddIdentityToGroupCommand extends ICommand {
    commandType: "addIdentityToGroup";
    groupId: string;
    memberId: string;
}

export /* abstract */ interface ICreateIdentityCommand extends ICommand {
    name: string;
}

export interface ICreateGroupCommand extends ICreateIdentityCommand {
    commandType: "createGroup";
}

export interface ICreateUserCommand extends ICreateIdentityCommand {
    commandType: "createUser";
    emailAddress: string;
    password: string;
}


// TODO  turn into classes since switch-statements is sufficiently Xtend-like


/**
 * Performs a basic syntax check of commands.
 * This is necessary since commands can come from un-/semi-trusted sources.
 * Events are considered to be generated by ourselves, so don't require syntax validation.
 */
export function validateSyntax(command: any): string[] {

    const issues: string[] = [];

    function checkString<T extends Command>(propertyName: keyof T) {
        const value = command[propertyName];
        if (!isString(value) || !value) {
            issues.push(`'${propertyName}' not valid`);
        }
    }

    if (isObject(issues)) {
        switch (command.commandType) {
            case "addIdentityToGroup": {
                checkString<IAddIdentityToGroupCommand>("groupId");
                checkString<IAddIdentityToGroupCommand>("memberId");
                break;
            }
            case "createGroup": {
                checkString<ICreateGroupCommand>("name");
                break;
            }
            case "createUser": {
                checkString<ICreateUserCommand>("name");
                checkString<ICreateUserCommand>("emailAddress");
                checkString<ICreateUserCommand>("password");
                break;
            }
            default: {
                issues.push("'commandType' not valid");
            }
        }
    } else {
        issues.push("not an object");
    }

    return issues;
}

// TODO  replace with JSON Schema check


function now() {
    return new Date();
}


export function commandProcessor(identities: Identities): (command: Command) => Promise<Event> {
    return command => {
        // TODO  handle error situation through promise
        // TODO  syntax of command should already have happened at this point
        const syntaxIssues = validateSyntax(command);
        if (syntaxIssues.length > 0) {
            return Promise.reject(syntaxIssues);
        }
        switch (command.commandType) {
            case "addIdentityToGroup": {
                const group = identities.byId(command.groupId);
                const member = identities.byId(command.memberId);
                if (group === undefined || group.identityType !== "group") {
                    return Promise.reject("group does not exist");
                }
                if (member === undefined) {
                    return Promise.reject("member does not exists");
                }
                if (member.id in group.members) {
                    return Promise.reject("member already in group");
                }
                if (identities.circularAfterAdding(group.id, member.id)) {
                    return Promise.reject("circularity not permitted");
                }
                return Promise.resolve({
                        eventType: "addIdentityToGroup",
                        timestamp: now(),
                        groupId: command.groupId,
                        memberId: command.memberId
                    } as IAddIdentityToGroupEvent);
            }
            case "createGroup": {
                // TODO  validate non-emptyness of name
                return Promise.resolve({
                        eventType: "createGroup",
                        id: v4(),
                        timestamp: now(),
                        name: command.name
                    } as ICreateGroupEvent);
            }
            case "createUser": {
                // TODO  validate non-emptyness of name
                // TODO  validate email address and password
                return (identities.userByEmailAddress(command.emailAddress) === undefined)
                    ? Promise.resolve({
                            eventType: "createUser",
                            id: v4(),
                            timestamp: now(),
                            name: command.name,
                            emailAddress: command.emailAddress,
                            hashedPassword: "salt$" + command.password    // TODO  really hash it
                        } as ICreateUserEvent)
                    : Promise.reject("user with that email address already exists");
            }
            /*
            * Note: if TypeScript insists on a default case, you've missed a case!
            * Conversely, `command` should have type `never` in the default case.
            */
        }
    };
}

